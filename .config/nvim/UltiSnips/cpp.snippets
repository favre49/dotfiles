snippet modmath
template<const int &MOD>
struct _m_int {
    int val;
 
    _m_int(int64_t v = 0) {
        if (v < 0) v = v % MOD + MOD;
        if (v >= MOD) v %= MOD;
        val = int(v);
    }
 
    _m_int(uint64_t v) {
        if (v >= MOD) v %= MOD;
        val = int(v);
    }
 
    _m_int(int v) : _m_int(int64_t(v)) {}
    _m_int(unsigned v) : _m_int(uint64_t(v)) {}
 
    static int inv_mod(int a, int m = MOD) {
        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example
        int g = m, r = a, x = 0, y = 1;
 
        while (r != 0) {
            int q = g / r;
            g %= r; swap(g, r);
            x -= q * y; swap(x, y);
        }
 
        return x < 0 ? x + m : x;
    }
 
    explicit operator int() const { return val; }
    explicit operator unsigned() const { return val; }
    explicit operator int64_t() const { return val; }
    explicit operator uint64_t() const { return val; }
    explicit operator double() const { return val; }
    explicit operator long double() const { return val; }
 
    _m_int& operator+=(const _m_int &other) {
        val -= MOD - other.val;
        if (val < 0) val += MOD;
        return *this;
    }
 
    _m_int& operator-=(const _m_int &other) {
        val -= other.val;
        if (val < 0) val += MOD;
        return *this;
    }
 
    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {
#if !defined(_WIN32) || defined(_WIN64)
        return unsigned(x % m);
#endif
        // Optimized mod for Codeforces 32-bit machines.
        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.
        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);
        unsigned quot, rem;
        asm("divl %4\n"
            : "=a" (quot), "=d" (rem)
            : "d" (x_high), "a" (x_low), "r" (m));
        return rem;
    }
 
    _m_int& operator*=(const _m_int &other) {
        val = fast_mod(uint64_t(val) * other.val);
        return *this;
    }
 
    _m_int& operator/=(const _m_int &other) {
        return *this *= other.inv();
    }
 
    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }
    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }
    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }
    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }
 
    _m_int& operator++() {
        val = val == MOD - 1 ? 0 : val + 1;
        return *this;
    }
 
    _m_int& operator--() {
        val = val == 0 ? MOD - 1 : val - 1;
        return *this;
    }
 
    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }
    _m_int operator--(int) { _m_int before = *this; --*this; return before; }
 
    _m_int operator-() const {
        return val == 0 ? 0 : MOD - val;
    }
 
    friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }
    friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }
    friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }
    friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }
    friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }
    friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }
 
    _m_int inv() const {
        return inv_mod(val);
    }
 
    _m_int pow(int64_t p) const {
        if (p < 0)
            return inv().pow(-p);
 
        _m_int a = *this, result = 1;
 
        while (p > 0) {
            if (p & 1)
                result *= a;
 
            p >>= 1;
 
            if (p > 0)
                a *= a;
        }
 
        return result;
    }
 
    friend ostream& operator<<(ostream &os, const _m_int &m) {
        return os << m.val;
    }
};

const int MOD = 998244353;
using mod_int = _m_int<MOD>;

endsnippet

snippet nck
const int N = 2e5 + 7;

mod_int fact[N], invfact[N], inv[N];

void init() {
  inv[1] = invfact[1] = invfact[0] = fact[0] = fact[1] = 1;
  for (int i = 2; i < N; i++) {
    fact[i] = fact[i - 1]*i;
    inv[i] = inv[MOD % i]*(MOD - MOD / i);
    invfact[i] = invfact[i - 1]*inv[i];
  }
}

mod_int cnk(int n, int k) {
  if (n < k) return 0;
  if (n < 0 || k < 0) return 0;
  return fact[n]*(invfact[k]*invfact[n - k]);
}
endsnippet

snippet dfs
void dfs(int s)
{
  if (visited[s])
    return;
  visited[s]=true;

  for (auto u: adj[s])
  {
    dfs(u);
  }
}
endsnippet

snippet bfs
void bfs(int s)
{
  visited[s] = true;
  dist[s] = 0;
  queue<int> q;
  q.push(s);
  while (!q.empty())
  {
    int x = q.front();
    q.pop();
    for (auto u : adj[x])
    {
	    if (visited[u]) continue;
	    visited[u] = true;
	    dist[u] = dist[x]+1;
	    q.push(u);
	  }
  }
}
endsnippet

snippet graphinput
repz(i,m)
{
  int x,y;
  cin >> x >> y;
  x--;
  y--;
  adj[x].pb(y);
  adj[y].pb(x);
}
endsnippet

snippet gcdfunc
ll gcd(ll x, ll y)
{
  if(y==0) return x;
  else return gcd(y,x%y);
}
endsnippet

snippet lcmfunc
ll lcm (ll a, ll b)
{
  return (a*b)/gcd(a,b); 
}
endsnippet

snippet tarjan
// comps stores the number of components, they are 1-indexed.
// comp stores the component number of any part
int low[N], dtime[N], dfstime, st[N], _size, comp[N], comps;
bool inst[N];

void tarjan(int u)
{
  low[u] = dtime[u] = ++dfstime;
  st[_size++] = u;
  inst[u] = true;
  for (int v : adj[u])
  {
    if (dtime[v]==-1)
    {
      tarjan(v);
      low[u] = min(low[u],low[v]);
    }
    else if (inst[v])
      low[u] = min(low[u],dtime[v]);
  }

  if (dtime[u] == low[u])
  {
    comps++;
    int v = -1;;
    do
    {
      v = st[--_size];
      inst[v] = false;
      comp[v] = comps;
    }
    while (u!=v);
  }
}

void scc(int n)
{
  comps = dfstime = _size = 0;
  memset(dtime,-1,sizeof(dtime));
  memset(low,0,sizeof(low));
  memset(st,0,sizeof(st));
  memset(comp,0,sizeof(comp));
  memset(inst,0,sizeof(inst));
  for (int i = 0; i < n; i++)
    if (dtime[i]==-1)
      tarjan(i);
}
endsnippet

snippet floyd
for (int k = 0; k < n; k++)
{
  for (int i = 0; i < n; i++)
  {
    for (int j = 0; j < n; j++)
    {
	    // Include if graph has negative edges
      //if (d[i][k] < INT_MAX && d[k][j] < INT_MAX)
	      d[i][j] = min(d[i][j],d[i][k]+d[k][j])
	  }
  }
}
endsnippet

snippet prefixfunc
// Finds longest prefix of [0..i] such that it is also a suffix of [0..i]
vi prefix_func(string s)
{
  int n = (int)s.length();
  vi pi(n);
  for (int i = 1; i < n; i++)
  {
    int j = pi[i-1];
    while (j > 0 && s[i] != s[j])
	    j = pi[j-1];
    if (s[i] == s[j])
	    j++;
    pi[i] = j;
  }
  return pi;
}
endsnippet

snippet BIT
struct BIT
{
  vi t;
  int tn;

  BIT(int _n)
  {
    assert(_n > 0);
    tn = _n;
    t = vi(tn+1,0);
  }

  void update(int x, int val)
  {
    x++;
    while (x <= tn)
    {
      t[x] += val;
      x += (x&-x);
    }
  }

  // Find sum in [0..x]
  int query(int x)
  {
    assert(x < tn);
    x++;
    int res = 0;
    while (x > 0)
    {
      res += t[x];
      x -= (x&-x);
    }
    return res;
  }

  // Find sum in [l..r]
  int get(int l, int r)
  {
    assert(l <= r);
    if (l==0)
      return query(r);
    return query(r)-query(l-1);
  }
};
endsnippet

snippet DSU
const int N = 1e5+7;
int parent[N], sz[N];

// Create a new set
void make_set(int v)
{
    parent[v] = v;
    sz[v] = 1;
}

// Find the set of v
int find_set(int v)
{
    if (v==parent[v])
        return v;
    
    // Path compression.
    return parent[v] = find_set(parent[v]);
}

// Unite two sets 
void union_sets(int a, int b)
{
    a = find_set(a);
    b = find_set(b);
    if (a != b)
    {
        if (sz[a] < sz[b])
	        swap(a,b);
        parent[b] = a;
        sz[a] += sz[b];
    }
}

endsnippet

snippet sieve
const int N = 1e5+7;
bool prime[N];

void sieve()
{
    memset(prime,true,sizeof(prime));

    for (int p = 2; p*p <= N; p++)
    {
        if (prime[p])
        {
	        for (int i = p*p; i <= N-1; i += p)
	          prime[i] = false;
        }
    }
}
endsnippet

snippet segtree
struct S {
  int x;

  // This should be the identity element
  S()
  {
    x = 0;
  }
  
  S(int _x):x(_x){}
};

S op(S& a, S& b)
{
  return {max(a.x,b.x)};
}

// Predicate for binary search. Must be true for identity.
bool f(S /*x*/)
{
  // Dummy for binary search
  return true;
}

struct segtree
{
  int _n;
  vector<S> t;
  int size;
  int log;

  segtree(): segtree(0) {}

  segtree(int n = -1)
  {
    if (n >= 0)
      init(n);
  }

  void init(int n)
  {
    _n = n;
    log = 0;
    while ((1U<<log) < (unsigned int)(n)) log++;
    size = 1<<log;
    t.assign(2*size,S());
  }

  void build(vector<S> v)
  {
    init((int)v.size());
    assert(_n != 0);

    for (int i = 0; i < _n; i++)
      t[size+i] = v[i];

    for (int i = size-1; i > 0; i--)
      t[i] = op(t[2*i],t[2*i+1]);
  }

  void set(int p, S x)
  {
    assert(0 <= p && p < _n);
    p += size;
    t[p] = x;
    for (int i = 1; i <= log; i++)
      t[p>>i] = op(t[2*(p>>i)],t[2*(p>>i)+1]);
  }

  S get(int p)
  {
    assert(0 <= p && p < _n);
    return t[p+size];
  }

  // Find result for range [l,r)
  S query (int l, int r)
  {
    assert(0 <= l && l <= r && r <= _n);
    S ansl, ansr;
    l += size;
    r += size;
    while (l < r)
    {
      if (l&1) ansl = op(ansl,t[l++]);
      if (r&1) ansr = op(t[--r],ansr);
      l >>= 1;
      r >>= 1;
    }
    return op(ansl,ansr);
  }

  /* Binary Search */
  // Find the maximum value of r such that [l,r) is true
  int max_right(int l)
  {
    assert(0 <= l && l <= _n);

    if (l==_n) return _n;
    l += size;
    S sm;
    do{
      while (l%2==0)
        l >>= 1;
      if (!f(op(sm,t[l])))
      {
        while (l < size) {
          l *= 2;
          if (f(op(sm,t[l])))
          {
            sm = op(sm,t[l]);
            l++;
          }
        }
        return l - size;
      }
      sm = op(sm,t[l]);
      l++;
    } while((l&-l) != l);
    return _n;
  }

  // This is the minimum l such that [l,r) is true
  int min_left(int r)
  {
    assert(0 <= r && r <= _n);
    if (r==0)
      return 0;
    r += size;
    S sm;
    do {
      r--;
      while(r>1 && (r%2)) r >>= 1;
      if (!f(op(t[r],sm)))
      {
        while (r < size)
        {
          r = (2*r+1);
          if (f(op(t[r],sm)))
          {
            sm = op(t[r],sm);
            r--;
          }
        }
        return r+1-size;
      }
      sm = op(t[r],sm);
    }
    while((r & -r) != r);
    return 0;
  }
};
endsnippet

snippet djikstra
const int N = 1e5+7;
const int INF = 100000000; // Consider changing to ll
vpii adj[N];
int dist[N];
int pred[N];
int n,m;

void djikstra(int src)
{
    fill(dist,dist+n,INF);
    fill(pred,pred+N,-1);
    dist[src] = 0;
    priority_queue<pii,vpii,greater<pii>> q;
    q.push({0,src});
    while (!q.empty())
    {
        int v = q.top().second;
        int d_v = q.top().first;
        q.pop();
        if (d_v != dist[v])
            continue;
        for (auto edge : adj[v])
        {
            int to = edge.f;
            int len = edge.s;
            
            if (dist[v] + len < dist[to])
            {
                dist[to] = dist[v] + len;
                pred[to] = v;
                q.push({dist[to],to});
            }
        }
    }
}
endsnippet

snippet trie
struct Trie
{
  static const int ALPHSIZE = 2;
  struct Node {
    // Keeps track of the index of the next node depending on the chosen
    // alphabet.
    int c[ALPHSIZE];

    // Each node has a count of how many of the same exist. If it is 0, the
    // string does not exist.
    int cnt;

    // This is the end of a string.
    bool end;

    Node() : cnt(0),end(false)
    {
      memset(c,0,sizeof(c));
    }
  };

  // At most Q strings of size L
  static const int L = 30, Q = 2e5+10;
  Node ns[(L+1)*Q];

  // Current nodecounter.
  int ncnt = 1;

  // Add x to the trie, where i is the root, and bit is the index we are
  // starting from.
  // To remove, let v = -1
  void update(int x, int v, int i = 1, int bit = L-1)
  {
    ns[i].cnt += v;
    if (bit < 0)
      return;
    int& c = ns[i].c[(x>>bit)&1];
    // If this doesn't already exist, we need to add the node.
    if (!c)
      c = ++ncnt;
    update(x,v,c,bit-1);
  }

  // Calculate maximum XOR with XOR.
  int query(int x, int i = 1, int bit = L-1)
  {
    if (bit < 0)
      return 0;
    int c = ns[i].c[!((x>>bit) & 1)];
    if (ns[c].cnt)
      return query(x,ns[i].c[!((x>>bit)&1)],bit-1) ^ (1<<bit);
    return query(x,ns[i].c[(x>>bit)&1],bit-1);
  }
};
endsnippet

snippet mrgsorttree
struct MergeSortTree
{
  vvi t;
  // Constructor
  MergeSortTree(int n) {
    t = vvi(4*n+7);
  }

  // Build the segment tree
  void build (vi& a, int v, int tl, int tr)
  {
    if (tl == tr)
    {
      // Base case.
      t[v] = vi(1,a[tl]);
    }
    else
    {
      // Merge the two nodes in a sorted order
      int tm = (tl+tr)/2;
      build(a,2*v,tl,tm);
      build(a,2*v+1,tm+1,tr);
      merge(full(t[2*v]),full(t[2*v+1]),back_inserter(t[v]));
    }
  }

  // Find count of indices in the range [l,r] such that it is >= x.
  int query(int v, int tl, int tr, int l, int r, int x)
  {
    if (l > r)
    {
      return 0;
    }
    if (l==tl && r == tr)
    {
      auto it = lower_bound(full(t[v]),x);
      return t[v].end() - it;
    }

    int tm = (tl+tr)/2;
    return query(2*v,tl,tm,l,min(r,tm),x) + query(2*v+1,tm+1,tr,max(tm+1,l),r,x);
  }
};
endsnippet

snippet bigint
const int BASE = 1e9;
const int BASE_DIGITS = 9;
struct BigInt {
    int sign;
    vector<int> a;

    // -------------------- Constructors -------------------- 
    // Default constructor.
    BigInt() : sign(1) {}

    // Constructor from long long.
    BigInt(long long v) {
        *this = v;
    }
    BigInt& operator = (long long v) {
        sign = 1;
        if (v < 0) {
            sign = -1;
            v = -v;
        }
        a.clear();
        for (; v > 0; v = v / BASE)
            a.push_back(v % BASE);
        return *this;
    }

    // Initialize from string.
    BigInt(const string& s) {
        read(s);
    }

    // -------------------- Input / Output --------------------
    void read(const string& s) {
        sign = 1;
        a.clear();
        int pos = 0;
        while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {
            if (s[pos] == '-')
                sign = -sign;
            ++pos;
        }
        for (int i = s.size() - 1; i >= pos; i -= BASE_DIGITS) {
            int x = 0;
            for (int j = max(pos, i - BASE_DIGITS + 1); j <= i; j++)
                x = x * 10 + s[j] - '0';
            a.push_back(x);
        }
        trim();
    }
    friend istream& operator>>(istream &stream, BigInt &v) {
        string s;
        stream >> s;
        v.read(s);
        return stream;
    }

    friend ostream& operator<<(ostream &stream, const BigInt &v) {
        if (v.sign == -1 && !v.isZero())
            stream << '-';
        stream << (v.a.empty() ? 0 : v.a.back());
        for (int i = (int) v.a.size() - 2; i >= 0; --i)
            stream << setw(BASE_DIGITS) << setfill('0') << v.a[i];
        return stream;
    }

    // -------------------- Comparison --------------------
    bool operator<(const BigInt &v) const {
        if (sign != v.sign)
            return sign < v.sign;
        if (a.size() != v.a.size())
            return a.size() * sign < v.a.size() * v.sign;
        for (int i = ((int) a.size()) - 1; i >= 0; i--)
            if (a[i] != v.a[i])
                return a[i] * sign < v.a[i] * sign;
        return false;
    }

    bool operator>(const BigInt &v) const {
        return v < *this;
    }
    bool operator<=(const BigInt &v) const {
        return !(v < *this);
    }
    bool operator>=(const BigInt &v) const {
        return !(*this < v);
    }
    bool operator==(const BigInt &v) const {
        return !(*this < v) && !(v < *this);
    }
    bool operator!=(const BigInt &v) const {
        return *this < v || v < *this;
    }

    // Returns:
    // 0 if |x| == |y|
    // -1 if |x| < |y|
    // 1 if |x| > |y|
    friend int __compare_abs(const BigInt& x, const BigInt& y) {
        if (x.a.size() != y.a.size()) {
            return x.a.size() < y.a.size() ? -1 : 1;
        }

        for (int i = ((int) x.a.size()) - 1; i >= 0; --i) {
            if (x.a[i] != y.a[i]) {
                return x.a[i] < y.a[i] ? -1 : 1;
            }
        }
        return 0;
    }

    // -------------------- Unary operator - and operators +- --------------------
    BigInt operator-() const {
        BigInt res = *this;
        if (isZero()) return res;

        res.sign = -sign;
        return res;
    }

    // Note: sign ignored.
    void __internal_add(const BigInt& v) {
        if (a.size() < v.a.size()) {
            a.resize(v.a.size(), 0);
        }
        for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {
            if (i == (int) a.size()) a.push_back(0);

            a[i] += carry + (i < (int) v.a.size() ? v.a[i] : 0);
            carry = a[i] >= BASE;
            if (carry) a[i] -= BASE;
        }
    }

    // Note: sign ignored.
    void __internal_sub(const BigInt& v) {
        for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {
            a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);
            carry = a[i] < 0;
            if (carry) a[i] += BASE;
        }
        this->trim();
    }

    BigInt operator += (const BigInt& v) {
        if (sign == v.sign) {
            __internal_add(v);
        } else {
            if (__compare_abs(*this, v) >= 0) {
                __internal_sub(v);
            } else {
                BigInt vv = v;
                swap(*this, vv);
                __internal_sub(vv);
            }
        }
        return *this;
    }

    BigInt operator -= (const BigInt& v) {
        if (sign == v.sign) {
            if (__compare_abs(*this, v) >= 0) {
                __internal_sub(v);
            } else {
                BigInt vv = v;
                swap(*this, vv);
                __internal_sub(vv);
                this->sign = -this->sign;
            }
        } else {
            __internal_add(v);
        }
        return *this;
    }

    // Optimize operators + and - according to
    // https://stackoverflow.com/questions/13166079/move-semantics-and-pass-by-rvalue-reference-in-overloaded-arithmetic
    template< typename L, typename R >
        typename std::enable_if<
            std::is_convertible<L, BigInt>::value &&
            std::is_convertible<R, BigInt>::value &&
            std::is_lvalue_reference<R&&>::value,
            BigInt>::type friend operator + (L&& l, R&& r) {
        BigInt result(std::forward<L>(l));
        result += r;
        return result;
    }
    template< typename L, typename R >
        typename std::enable_if<
            std::is_convertible<L, BigInt>::value &&
            std::is_convertible<R, BigInt>::value &&
            std::is_rvalue_reference<R&&>::value,
            BigInt>::type friend operator + (L&& l, R&& r) {
        BigInt result(std::move(r));
        result += l;
        return result;
    }

    template< typename L, typename R >
        typename std::enable_if<
            std::is_convertible<L, BigInt>::value &&
            std::is_convertible<R, BigInt>::value,
            BigInt>::type friend operator - (L&& l, R&& r) {
        BigInt result(std::forward<L>(l));
        result -= r;
        return result;
    }

    // -------------------- Operators * / % --------------------
    friend pair<BigInt, BigInt> divmod(const BigInt& a1, const BigInt& b1) {
        assert(b1 > 0);  // divmod not well-defined for b < 0.

        long long norm = BASE / (b1.a.back() + 1);
        BigInt a = a1.abs() * norm;
        BigInt b = b1.abs() * norm;
        BigInt q = 0, r = 0;
        q.a.resize(a.a.size());

        for (int i = a.a.size() - 1; i >= 0; i--) {
            r *= BASE;
            r += a.a[i];
            long long s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];
            long long s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];
            long long d = ((long long) BASE * s1 + s2) / b.a.back();
            r -= b * d;
            while (r < 0) {
                r += b, --d;
            }
            q.a[i] = d;
        }

        q.sign = a1.sign * b1.sign;
        r.sign = a1.sign;
        q.trim();
        r.trim();
        auto res = make_pair(q, r / norm);
        if (res.second < 0) res.second += b1;
        return res;
    }
    BigInt operator/(const BigInt &v) const {
        return divmod(*this, v).first;
    }

    BigInt operator%(const BigInt &v) const {
        return divmod(*this, v).second;
    }

    void operator/=(int v) {
        assert(v > 0);  // operator / not well-defined for v <= 0.
        if (llabs(v) >= BASE) {
            *this /= BigInt(v);
            return ;
        }
        if (v < 0)
            sign = -sign, v = -v;
        for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {
            long long cur = a[i] + rem * (long long) BASE;
            a[i] = (int) (cur / v);
            rem = (int) (cur % v);
        }
        trim();
    }

    BigInt operator/(int v) const {
        assert(v > 0);  // operator / not well-defined for v <= 0.

        if (llabs(v) >= BASE) {
            return *this / BigInt(v);
        }
        BigInt res = *this;
        res /= v;
        return res;
    }
    void operator/=(const BigInt &v) {
        *this = *this / v;
    }

    long long operator%(long long v) const {
        assert(v > 0);  // operator / not well-defined for v <= 0.
        assert(v < BASE);
        int m = 0;
        for (int i = a.size() - 1; i >= 0; --i)
            m = (a[i] + m * (long long) BASE) % v;
        return m * sign;
    }

    void operator*=(int v) {
        if (llabs(v) >= BASE) {
            *this *= BigInt(v);
            return ;
        }
        if (v < 0)
            sign = -sign, v = -v;
        for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {
            if (i == (int) a.size())
                a.push_back(0);
            long long cur = a[i] * (long long) v + carry;
            carry = (int) (cur / BASE);
            a[i] = (int) (cur % BASE);
            //asm("divl %%ecx" : "=a"(carry), "=d"(a[i]) : "A"(cur), "c"(base));
            /*
             int val;
             __asm {
             lea esi, cur
             mov eax, [esi]
             mov edx, [esi+4]
             mov ecx, base
             div ecx
             mov carry, eax
             mov val, edx;
             }
             a[i] = val;
             */
        }
        trim();
    }

    BigInt operator*(int v) const {
        if (llabs(v) >= BASE) {
            return *this * BigInt(v);
        }
        BigInt res = *this;
        res *= v;
        return res;
    }

    // Convert BASE 10^old --> 10^new.
    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {
        vector<long long> p(max(old_digits, new_digits) + 1);
        p[0] = 1;
        for (int i = 1; i < (int) p.size(); i++)
            p[i] = p[i - 1] * 10;
        vector<int> res;
        long long cur = 0;
        int cur_digits = 0;
        for (int i = 0; i < (int) a.size(); i++) {
            cur += a[i] * p[cur_digits];
            cur_digits += old_digits;
            while (cur_digits >= new_digits) {
                res.push_back((long long)(cur % p[new_digits]));
                cur /= p[new_digits];
                cur_digits -= new_digits;
            }
        }
        res.push_back((int) cur);
        while (!res.empty() && !res.back())
            res.pop_back();
        return res;
    }

    void fft(vector<complex<double> > & a, bool invert) const {
        int n = (int) a.size();

        for (int i = 1, j = 0; i < n; ++i) {
            int bit = n >> 1;
            for (; j >= bit; bit >>= 1)
                j -= bit;
            j += bit;
            if (i < j)
                swap(a[i], a[j]);
        }

        for (int len = 2; len <= n; len <<= 1) {
            double ang = 2 * 3.14159265358979323846 / len * (invert ? -1 : 1);
            complex<double> wlen(cos(ang), sin(ang));
            for (int i = 0; i < n; i += len) {
                complex<double> w(1);
                for (int j = 0; j < len / 2; ++j) {
                    complex<double> u = a[i + j];
                    complex<double> v = a[i + j + len / 2] * w;
                    a[i + j] = u + v;
                    a[i + j + len / 2] = u - v;
                    w *= wlen;
                }
            }
        }
        if (invert)
            for (int i = 0; i < n; ++i)
                a[i] /= n;
    }

    void multiply_fft(const vector<int> &a, const vector<int> &b, vector<int> &res) const {
        vector<complex<double> > fa(a.begin(), a.end());
        vector<complex<double> > fb(b.begin(), b.end());
        int n = 1;
        while (n < (int) max(a.size(), b.size()))
            n <<= 1;
        n <<= 1;
        fa.resize(n);
        fb.resize(n);

        fft(fa, false);
        fft(fb, false);
        for (int i = 0; i < n; ++i)
            fa[i] *= fb[i];
        fft(fa, true);

        res.resize(n);
        long long carry = 0;
        for (int i = 0; i < n; ++i) {
            long long t = (long long) (fa[i].real() + 0.5) + carry;
            carry = t / 1000;
            res[i] = t % 1000;
        }
    }

    BigInt mul_simple(const BigInt &v) const {
        BigInt res;
        res.sign = sign * v.sign;
        res.a.resize(a.size() + v.a.size());
        for (int i = 0; i < (int) a.size(); ++i)
            if (a[i])
                for (int j = 0, carry = 0; j < (int) v.a.size() || carry; ++j) {
                    long long cur = res.a[i + j] + (long long) a[i] * (j < (int) v.a.size() ? v.a[j] : 0) + carry;
                    carry = (int) (cur / BASE);
                    res.a[i + j] = (int) (cur % BASE);
                }
        res.trim();
        return res;
    }

    typedef vector<long long> vll;

    static vll karatsubaMultiply(const vll &a, const vll &b) {
        int n = a.size();
        vll res(n + n);
        if (n <= 32) {
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    res[i + j] += a[i] * b[j];
            return res;
        }

        int k = n >> 1;
        vll a1(a.begin(), a.begin() + k);
        vll a2(a.begin() + k, a.end());
        vll b1(b.begin(), b.begin() + k);
        vll b2(b.begin() + k, b.end());

        vll a1b1 = karatsubaMultiply(a1, b1);
        vll a2b2 = karatsubaMultiply(a2, b2);

        for (int i = 0; i < k; i++)
            a2[i] += a1[i];
        for (int i = 0; i < k; i++)
            b2[i] += b1[i];

        vll r = karatsubaMultiply(a2, b2);
        for (int i = 0; i < (int) a1b1.size(); i++)
            r[i] -= a1b1[i];
        for (int i = 0; i < (int) a2b2.size(); i++)
            r[i] -= a2b2[i];

        for (int i = 0; i < (int) r.size(); i++)
            res[i + k] += r[i];
        for (int i = 0; i < (int) a1b1.size(); i++)
            res[i] += a1b1[i];
        for (int i = 0; i < (int) a2b2.size(); i++)
            res[i + n] += a2b2[i];
        return res;
    }

    BigInt mul_karatsuba(const BigInt &v) const {
        vector<int> a6 = convert_base(this->a, BASE_DIGITS, 6);
        vector<int> b6 = convert_base(v.a, BASE_DIGITS, 6);
        vll a(a6.begin(), a6.end());
        vll b(b6.begin(), b6.end());
        while (a.size() < b.size())
            a.push_back(0);
        while (b.size() < a.size())
            b.push_back(0);
        while (a.size() & (a.size() - 1))
            a.push_back(0), b.push_back(0);
        vll c = karatsubaMultiply(a, b);
        BigInt res;
        res.sign = sign * v.sign;
        long long carry = 0;
        for (int i = 0; i < (int) c.size(); i++) {
            long long cur = c[i] + carry;
            res.a.push_back((int) (cur % 1000000));
            carry = cur / 1000000;
        }
        res.a = convert_base(res.a, 6, BASE_DIGITS);
        res.trim();
        return res;
    }

    void operator*=(const BigInt &v) {
        *this = *this * v;
    }
    BigInt operator*(const BigInt &v) const {
        if (a.size() * v.a.size() <= 1000111) return mul_simple(v);
        if (a.size() > 500111 || v.a.size() > 500111) return mul_fft(v);
        return mul_karatsuba(v);
    }

    BigInt mul_fft(const BigInt& v) const {
        BigInt res;
        res.sign = sign * v.sign;
        multiply_fft(convert_base(a, BASE_DIGITS, 3), convert_base(v.a, BASE_DIGITS, 3), res.a);
        res.a = convert_base(res.a, 3, BASE_DIGITS);
        res.trim();
        return res;
    }

    // -------------------- Misc --------------------
    BigInt abs() const {
        BigInt res = *this;
        res.sign *= res.sign;
        return res;
    }
    void trim() {
        while (!a.empty() && !a.back())
            a.pop_back();
        if (a.empty())
            sign = 1;
    }

    bool isZero() const {
        return a.empty() || (a.size() == 1 && !a[0]);
    }

    friend BigInt gcd(const BigInt &a, const BigInt &b) {
        return b.isZero() ? a : gcd(b, a % b);
    }
    friend BigInt lcm(const BigInt &a, const BigInt &b) {
        return a / gcd(a, b) * b;
    }

    friend BigInt sqrt(const BigInt &a1) {
        BigInt a = a1;
        while (a.a.empty() || a.a.size() % 2 == 1)
            a.a.push_back(0);

        int n = a.a.size();

        int firstDigit = (int) sqrt((double) a.a[n - 1] * BASE + a.a[n - 2]);
        int norm = BASE / (firstDigit + 1);
        a *= norm;
        a *= norm;
        while (a.a.empty() || a.a.size() % 2 == 1)
            a.a.push_back(0);

        BigInt r = (long long) a.a[n - 1] * BASE + a.a[n - 2];
        firstDigit = (int) sqrt((double) a.a[n - 1] * BASE + a.a[n - 2]);
        int q = firstDigit;
        BigInt res;

        for(int j = n / 2 - 1; j >= 0; j--) {
            for(; ; --q) {
                BigInt r1 = (r - (res * 2 * BigInt(BASE) + q) * q) * BigInt(BASE) * BigInt(BASE) + (j > 0 ? (long long) a.a[2 * j - 1] * BASE + a.a[2 * j - 2] : 0);
                if (r1 >= 0) {
                    r = r1;
                    break;
                }
            }
            res *= BASE;
            res += q;

            if (j > 0) {
                int d1 = res.a.size() + 2 < r.a.size() ? r.a[res.a.size() + 2] : 0;
                int d2 = res.a.size() + 1 < r.a.size() ? r.a[res.a.size() + 1] : 0;
                int d3 = res.a.size() < r.a.size() ? r.a[res.a.size()] : 0;
                q = ((long long) d1 * BASE * BASE + (long long) d2 * BASE + d3) / (firstDigit * 2);
            }
        }

        res.trim();
        return res / norm;
    }
};
endsnippet

snippet zfunction
vector<int> z_function(string s) {
    int n = (int) s.length();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r)
            z[i] = min (r - i + 1, z[i - l]);
        while (i + z[i] < n && s[z[i]] == s[i + z[i]])
            ++z[i];
        if (i + z[i] - 1 > r)
            l = i, r = i + z[i] - 1;
    }
    return z;
}
endsnippet

snippet rollinghash
// Use mode 1e9+7;
int tmp = (chrono::high_resolution_clock::now().time_since_epoch().count()%MOD+MOD)%MOD;

pair<mod_int,mod_int> operator+(const pair<mod_int,mod_int>& l, const pair<mod_int,mod_int> r)
{  return {l.f+r.f,l.s+r.s}; }

pair<mod_int,mod_int> operator-(const pair<mod_int,mod_int>& l, const pair<mod_int,mod_int> r)
{  return {l.f-r.f,l.s-r.s}; }

pair<mod_int,mod_int> operator*(const pair<mod_int,mod_int>& l, const pair<mod_int,mod_int> r)
{  return {l.f*r.f,l.s*r.s}; }

pair<mod_int,mod_int> operator*(const pair<mod_int,mod_int>& l, int r) { return {l.f*r,l.s*r}; };

struct hsh
{
  string S;
  vector<pair<mod_int,mod_int>> pows, ipows, cum;
  pair<mod_int,mod_int> base = {948392576,tmp}, invbase;

  hsh() {}
  hsh(string s) { gen(s); }

  void gen(string _S)
  {
    if (base.s==0)
      base.s = 1358;
    invbase = {base.f.inv(),base.s.inv()};
    S = _S;
    pows.resize(S.size()), ipows.resize(S.size()), cum.resize(S.size()+1);
    pows[0] = ipows[0] = {1,1};
    for (int i = 1; i < (int)S.size(); i++)
    {
      pows[i] = pows[i-1]*base;
      ipows[i] = ipows[i-1]*invbase;
    }

    for (int i = 0; i < (int)S.size(); i++)
      cum[i+1] = cum[i] + pows[i]*(int)(S[i]-'a'+1);;
  }

  // Get the hash of the subtring [l,r]
  pair<mod_int,mod_int> get(int l, int r)
  {
    return ipows[l]*(cum[r+1]-cum[l]);
  }

  int lcp(hsh& b)
  {
    int lo = 0, hi = min(S.size(),b.S.size());
    while (lo < hi)
    {
      int mid = (lo+hi+1)/2;
      if (cum[mid] == b.cum[mid]) lo = mid;
      else
        hi = mid-1;
    }
    return lo;
  }
};
endsnippet

snippet lazysegtree
struct S {
  int x;
  int w;

  // This should be the identity element
  S()
  {
    x = 0;
    w = 1;
  }
  
  S(int _x, int _w):x(_x), w(_w){}
};

// Paremeters of the function we are applying on the range.
struct F{
  int d;
  // Must be identity
  F() {d=0;}
  F(int _d):d(_d){}
};

// Returns the transform with parameters F and input S
S mapping(F f, S x)
{
  if (f.d==0)
    return x;
  return S();
}

// Returns f o g, which is the composition of them under the operation op
// It is necessary that f(x) o f(y) = f(x o y)
F composition(F f, F g)
{
  if (f.d==0) return g;
  return f;
}

S op(S a, S b)
{
  return S(a.x*b.w+b.x,a.w*b.w);
}

// Predicate for binary search. Must be true for identity.
bool f(S /*x*/)
{
  // Dummy for binary search
  return true;
}

struct lazy_segtree
{
  int _n;
  vector<S> t;
  vector<F> lz;
  int size;
  int log;

  lazy_segtree(): lazy_segtree(0) {}

  lazy_segtree(int n = -1)
  {
    if (n >= 0)
      init(n);
  }

  lazy_segtree(vector<S> v)
  {
    build(v);
  }

  void init(int n)
  {
    _n = n;
    log = 0;
    while ((1U<<log) < (unsigned int)(n)) log++;
    size = 1<<log;
    t.assign(2*size,S());
    lz = vector<F>(size);
  }

  void build(vector<S> v)
  {
    init((int)v.size());
    assert(_n != 0);

    for (int i = 0; i < _n; i++)
      t[size+i] = v[i];

    for (int i = size-1; i > 0; i--)
      t[i] = op(t[2*i],t[2*i+1]);
  }

  void all_apply(int k, F f)
  {
    t[k] = mapping(f,t[k]);
    if (k < size) lz[k] = composition(f,lz[k]);
  }

  void push(int k)
  {
    all_apply(2*k,lz[k]);
    all_apply(2*k+1,lz[k]);
    lz[k] = F();
  }

  void set(int p, S x)
  {
    assert(0 <= p && p < _n);
    p += size;
    for (int i = log; i >= 1; i--)
      push(p>>i);
    t[p] = x;
    for (int i = 1; i <= log; i++)
      t[p>>i] = op(t[2*(p>>i)],t[2*(p>>i)+1]);
  }

  S get(int p)
  {
    assert(0 <= p && p < _n);
    p += size;
    for (int i = log; i >= 1; i--)
      push(p>>i);
    return t[p];
  }

  // Find result for range [l,r)
  S query (int l, int r)
  {
    assert(0 <= l && l <= r && r <= _n);
    if (l==r) return S();
    S ansl, ansr;
    l += size;
    r += size;

    for (int i = log; i >= 1; i--)
    {
      if (((l>>i)<<i) != l) push (l>>i);
      if (((r>>i)<<i) != r) push (r>>i);
    }

    while (l < r)
    {
      if (l&1) ansl = op(ansl,t[l++]);
      if (r&1) ansr = op(t[--r],ansr);
      l >>= 1;
      r >>= 1;
    }
    return op(ansl,ansr);
  }

  void apply(int p, F f)
  {
    assert(0 <= p && p < _n);
    p += size;
    for (int i = log; i >= 1; i--)
      push(p>>i);
    t[p] = mapping(f,t[p]);
    for (int i = 1; i <= log; i++)
      t[p>>i] = op(t[2*(p>>i)],t[2*(p>>i)+1]);
  }

  void apply(int l, int r, F f)
  {
    assert(0 <= l && l <= r && r <= _n);
    if (l==r) return;

    l += size;
    r += size;

    for (int i = log; i >= 1; i--)
    {
      if (((l >> i)<<i)!=l) push(l>>i);
      if (((r >> i)<<i)!=r) push((r-1)>>i);
    }

    {
      int l2 = l, r2 = r;
      while (l < r)
      {
        if (l&1) all_apply(l++,f);
        if (r&1) all_apply(--r,f);
        l >>= 1;
        r >>= 1;
      }
      l = l2, r = r2;
    }

    for (int i = 1; i <= log; i++)
    {
      if (((l >> i)<<i)!=l) t[l>>i] = op(t[2*(l>>i)],t[2*(l>>i)+1]);
      if (((r >> i)<<i)!=r) t[(r-1)>>i] = op(t[2*((r-1)>>i)],t[2*((r-1)>>i)+1]);
    }
  }

  /* Binary Search */
  // Find the maximum value of r such that [l,r) is true
  int max_right(int l)
  {
    assert(0 <= l && l <= _n);

    if (l==_n) return _n;
    l += size;
    for (int i = log; i >= 1; i--)
      push(l>>i);
    S sm;
    do{
      while (l%2==0)
        l >>= 1;
      if (!f(op(sm,t[l])))
      {
        while (l < size) {
          push(l);
          l *= 2;
          if (f(op(sm,t[l])))
          {
            sm = op(sm,t[l]);
            l++;
          }
        }
        return l - size;
      }
      sm = op(sm,t[l]);
      l++;
    } while((l&-l) != l);
    return _n;
  }

  // This is the minimum l such that [l,r) is true
  int min_left(int r)
  {
    assert(0 <= r && r <= _n);
    if (r==0)
      return 0;
    r += size;
    for (int i = log; i >= 1; i--)
      push((r-1)<<i);
    S sm;
    do {
      r--;
      while(r>1 && (r%2)) r >>= 1;
      if (!f(op(t[r],sm)))
      {
        while (r < size)
        {
          push(r);
          r = (2*r+1);
          if (f(op(t[r],sm)))
          {
            sm = op(t[r],sm);
            r--;
          }
        }
        return r+1-size;
      }
      sm = op(t[r],sm);
    }
    while((r & -r) != r);
    return 0;
  }
};
endsnippet

snippet matrix
template<class T>
struct Mat{
  int n,m;
  vector<vector<T>> d;

  Mat()
  {
    n = 0, m = 0;
  }

  Mat(int _n, int _m): n(_n), m(_m)
  {
    d = vector<vector<T>>(n,vector<mod_int>(m));
  }

  Mat(const vector<vector<T>>& v): Mat((int)v.size(),(int)v[0].size()){
    for (int i = 0; i < n; i++)
      for (int j = 0; j < m; j++)
        d[i][j] = v[i][j];
  }

  Mat operator +(Mat other) {
    assert(n == other.n && m == other.m);
    Mat res = Mat(n,m);
    for (int i = 0; i < n; i++)
    {
      for (int j = 0; j < m; j++)
      {
        res.d[i][j] = d[i][j] + other.d[i][j];
      }
    }
    return res;
  }

  Mat operator -(Mat other) {
    assert(n == other.n && m == other.m);
    Mat res = Mat(n,m);
    for (int i = 0; i < n; i++)
    {
      for (int j = 0; j < m; j++)
      {
        res.d[i][j] = d[i][j] - other.d[i][j];
      }
    }
    return res;
  }

  Mat operator *(Mat other) {
    assert(m == other.n);
    Mat prod = Mat(n,other.m);
    for (int i = 0; i < n; i++)
    {
      for (int j = 0; j < m; j++)
      {
        for (int k = 0; k < other.m; k++)
        {
          prod.d[i][k] += d[i][j] * other.d[j][k];
        }
      }
    }
    return prod;
  }

  Mat operator ^(ll p)
  {
    assert(p >= 0);
    Mat res(n,n), base(*this);
    for (int i = 0; i < n; i++)
      res.d[i][i] = 1;
    for (;p; p /= 2)
    {
      if (p&1) res = res*base;
      base = base*base;
    }
    return res;
  }
};
endsnippet

snippet polynomial
template <typename T>
struct poly {
  // The coefficients of the polynomial in increasing order of degree
  vector<T> a;

  // Constructors
  poly(){}
  poly(T _a):a{_a} {}
  poly(vector<T> t):a(t) {}

  // Operations
  poly operator += (const poly& t)
  {
    a.resize(max(a.size(),t.a.size()));
    for (int i = 0; i< t.a.size(); i++)
      a[i] += t.a[i];
    return *this;
  }

  poly operator -= (const poly& t)
  {
    a.resize(max(a.size(),t.a.size()));
    for (int i = 0; i< t.a.size(); i++)
      a[i] -= t.a[i];
    return *this;
  }

  // Note: Should I make this FFT? Probably not yet
  poly operator *= (const poly& t)
  {
    vector<T> ans(a.size()+t.a.size()-1);
    for (int i = 0; i < (int)a.size(); i++)
      for (int j = 0; j < (int)t.a.size(); j++)
        ans[i+j] += a[i]*t.a[j];
    a = ans;
    return *this;
  }

  poly operator /= (T d)
  {
    for (int i = 0; i < a.size(); i++)
      a[i] /= d;
    return *this;
  }

  T operator () (T x)
  {
    T res = 0;
    T cum = 1;
    for (int i = 0; i < a.size(); i++)
    {
      res += a[i]*cum;
      cum *= x;
    }
    return res;
  }

  poly operator + (const poly& t) const {return poly(*this) += t;}
  poly operator - (const poly& t) const {return poly(*this) -= t;}
  poly operator * (const poly& t) const {return poly(*this) *= t;}
  poly operator / (T t) const {return poly(*this) /= t;}

  // More operations
  poly integrate()
  {
    vector<T> res = {0};
    for (int i = 0; i < a.size(); i++)
    {
      res.pb(a[i]/T(i+1));
    }
    return res;
  }

  poly deriv()
  {
    vector<T> res;
    for (int i = 1; i < a.size(); i++)
      res.pb(a[i]*T(i));
    return res;
  }
  
  T integrate_val(int l, int r)
  {
    poly ans = integrate();
    return ans(r)-ans(l);
  }
};
endsnippet
