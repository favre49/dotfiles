snippet modmath
ll mod = 998244353;

ll mult(ll a, ll b)
{
  return (1LL * a * b) % mod;
}

ll pw(ll a, ll b)
{
  if (b == 0) return 1;
  if (b & 1) return mult(a, pw(a, b - 1));
  ll res = pw(a, b / 2);
  return mult(res, res);
}

ll sub(ll a, ll b) {
  ll s = a - b;
  if (s < 0) s += mod;
  return s;
}

ll add(ll a, ll b) {
  ll s = a + b;
  if (s >= mod) s -= mod;
  return s;
}
endsnippet

snippet nck
const int maxN = 2 * (int)1e5 + 100;

int fact[maxN], invfact[maxN], inv[maxN];

void init() {
  inv[1] = invfact[1] = invfact[0] = fact[0] = fact[1] = 1;
  for (int i = 2; i < maxN; i++) {
    fact[i] = mult(fact[i - 1], i);
    inv[i] = mult(inv[mod % i], mod - mod / i);
    invfact[i] = mult(invfact[i - 1], inv[i]);
  }
}

int cnk(int n, int k) {
  if (n < k) return 0;
  if (n < 0 || k < 0) return 0;
  return mult(fact[n], mult(invfact[k], invfact[n - k]));
}
endsnippet

snippet dfs
void dfs(int s)
{
  if (visited[s])
    return;
  visited[s]=true;

  for (auto u: adj[s])
  {
    dfs(u);
  }
}
endsnippet

snippet bfs
void bfs(int s)
{
  visited[s] = true;
  dist[s] = 0;
  queue<int> q;
  q.push(s);
  while (!q.empty())
  {
    int x = q.front();
    q.pop();
    for (auto u : adj[x])
    {
	    if (visited[u]) continue;
	    visited[u] = true;
	    dist[u] = dist[x]+1;
	    q.push(u);
	  }
  }
}
endsnippet

snippet graphinput
repz(i,m)
{
  int x,y;
  cin >> x >> y;
  x--;
  y--;
  adj[x].pb(y);
  adj[y].pb(x);
}
endsnippet

snippet gcdfunc
ll gcd(ll x, ll y)
{
  if(y==0) return x;
  else return gcd(y,x%y);
}
endsnippet

snippet lcmfunc
ll lcm (ll a, ll b)
{
  return (a*b)/gcd(a,b); 
}
endsnippet

snippet tarjan
// comps stores the number of components, they are 1-indexed.
// comp stores the component number of any part
int low[N], dtime[N], dfstime, st[N], _size, comp[N], comps;
bool inst[N];

void tarjan(int u)
{
  low[u] = dtime[u] = ++dfstime;
  st[_size++] = u;
  inst[u] = true;
  for (int v : adj[u])
  {
    if (dtime[v]==-1)
    {
      tarjan(v);
      low[u] = min(low[u],low[v]);
    }
    else if (inst[v])
      low[u] = min(low[u],dtime[v]);
  }

  if (dtime[u] == low[u])
  {
    comps++;
    int v = -1;;
    do
    {
      v = st[--_size];
      inst[v] = false;
      comp[v] = comps;
    }
    while (u!=v);
  }
}

void scc(int n)
{
  comps = dfstime = _size = 0;
  memset(dtime,-1,sizeof(dtime));
  memset(low,0,sizeof(low));
  memset(st,0,sizeof(st));
  memset(comp,0,sizeof(comp));
  memset(inst,0,sizeof(inst));
  for (int i = 0; i < n; i++)
    if (dtime[i]==-1)
      tarjan(i);
}
endsnippet

snippet floyd
for (int k = 0; k < n; k++)
{
  for (int i = 0; i < n; i++)
  {
    for (int j = 0; j < n; j++)
    {
	    // Include if graph has negative edges
	    if (d[i][k] < INT_MAX && d[k][j] < INT_MAX)
	      d[i][j] = min(d[i][j],d[i][k]+d[k][j])
	  }
  }
}
endsnippet

snippet prefixfunc
// Finds longest prefix of [0..i] such that it is also a suffix of [0..i]
vi prefix_func(string s)
{
  int n = (int)s.length();
  vi pi(n);
  for (int i = 1; i < n; i++)
  {
    int j = pi[i-1];
    while (j > 0 && s[i] != s[j])
	    j = pi[j-1];
    if (s[i] == s[j])
	    j++;
    pi[i] = j;
  }
  return pi;
}
endsnippet

snippet BIT

const int N = 1e5+7;
int BIT[N];

// Increase number indexed at x by val
void update(int x, int val)
{
    x++;
    while (x <= N)
    {
        BIT[x] += val;
        x += (x & -x);
    }
}

// Find sum of range [0...x]
int query(int x)
{
    x++;
    int res = 0;
    while (x > 0)
    {
        res += BIT[x];
        x -= (x & -x);
    }
    return res;
}

endsnippet

snippet DSU

int parent[N], sz[N];

// Create a new set
void make_set(int v)
{
    parent[v] = v;
    sz(v) = 1;
}

// Find the set of v
int find_set(int v)
{
    if (v==parent[v])
        return v;
    
    // Path compression.
    return parent[v] = find_set(parent[v]);
}

// Unite two sets 
void union_sets(int a, int b)
{
    a = find_set(a);
    b = find_set(b);
    if (a != b)
    {
        if (sz(a) < sz(b))
	    swap(a,b);
        parent[b] = a;
        sz[a] += sz[b];
    }
}

endsnippet

snippet sieve
const int N = 1e5+7;
bool prime[N];

void sieve()
{
    memset(prime,true,sizeof(prime));

    for (int p = 2; p*p <= N; p++)
    {
        if (prime[p])
        {
	        for (int i = p*p; i <= N-1; i += p)
	          prime[i] = false;
        }
    }
}
endsnippet

snippet segtree

const int N = 2e5+7;
int a[N]; // The array from which we build the segtree

// Rememver to change the operations in ALL FUNCTIONS
// Remember to fix the default value of ALL THE THINGS
struct SegTree {
  int n;
  vi t;

  SegTree(int _n) : n(_n)
  {
    t = vi(4*n+7,INT_MAX);;
  }

  // Construct segtree, call with build(1,0,n-1)
  void build(int v, int tl, int tr)
  {
    if (tl==tr)
    {
      t[v] = a[tl];
    }
    else
    {
      int tm = (tl+tr)/2;
      build(2*v,tl,tm);
      build(2*v+1,tm+1,tr);
      t[v] = min(t[2*v],t[2*v+1]);
    }
  }

  int query(int v, int tl, int tr, int l, int r)
  {
    // Wrong segment
    if (l>r)
      return INT_MAX;
    
    // Exactly matching segment
    if (l==tl && r == tr)
      return t[v];

    int tm = (tl+tr)/2;
    return min(query(2*v,tl,tm,l,min(r,tm)),query(2*v+1,tm+1,tr,max(l,tm+1),r));
  }

  void update(int v, int tl, int tr, int pos, int new_val) {
    if(tl==tr)
      t[v] = new_val;
    else
    {
      int tm = (tl+tr)/2;
      if (pos <= tm)
        update(2*v,tl,tm,pos,new_val);
      else update(2*v+1,tm+1,tr,pos,new_val);
      t[v] = min(t[2*v],t[2*v+1]);
    }
  }
};

endsnippet

snippet djikstra
const int N = 1e5+7;
const int INF = 100000000;
vpii adj[N];
int dist[N];
int pred[N];
int n,m;

void djikstra(int src)
{
    fill(dist,dist+n,INF);
    fill(pred,pred+N,-1);

    dist[src] = 0;
    
    priority_queue<pii,vpii,greater<pii>> q;
    q.push({0,src});
    while (!q.empty())
    {
        int v = q.top().second;
        int d_v = q.top().first;
        q.pop();
        if (d_v != dist[v])
            continue;

        for (auto edge : adj[v])
        {
            int to = edge.f;
            int len = edge.s;
            
            if (dist[v] + len < dist[to])
            {
                dist[to] = dist[v] + len;
                pred[to] = v;
                q.push({dist[to],to});
            }
        }
    }

}
endsnippet

snippet trie
struct Trie
{
  static const int ALPHSIZE = 2;
  struct Node {
    // Keeps track of the index of the next node depending on the chosen
    // alphabet.
    int c[ALPHSIZE];

    // Each node has a count of how many of the same exist. If it is 0, the
    // string does not exist.
    int cnt;

    // This is the end of a string.
    bool end;

    Node() : cnt(0),end(false)
    {
      memset(c,0,sizeof(c));
    }
  };

  // At most Q strings of size L
  static const int L = 30, Q = 2e5+10;
  Node ns[(L+1)*Q];

  // Current nodecounter.
  int ncnt = 1;

  // Add x to the trie, where i is the root, and bit is the index we are
  // starting from.
  // To remove, let v = -1
  void update(int x, int v, int i = 1, int bit = L-1)
  {
    ns[i].cnt += v;
    if (bit < 0)
      return;
    int& c = ns[i].c[(x>>bit)&1];
    // If this doesn't already exist, we need to add the node.
    if (!c)
      c = ++ncnt;
    update(x,v,c,bit-1);
  }

  // Calculate maximum XOR with XOR.
  int query(int x, int i = 1, int bit = L-1)
  {
    if (bit < 0)
      return 0;
    int c = ns[i].c[!((x>>bit) & 1)];
    if (ns[c].cnt)
      return query(x,ns[i].c[!((x>>bit)&1)],bit-1) ^ (1<<bit);
    return query(x,ns[i].c[(x>>bit)&1],bit-1);
  }
};
endsnippet

snippet mrgsorttree
struct MergeSortTree
{
  vvi t;
  // Constructor
  MergeSortTree(int n) {
    t = vvi(4*n+7);
  }

  // Build the segment tree
  void build (vi& a, int v, int tl, int tr)
  {
    if (tl == tr)
    {
      // Base case.
      t[v] = vi(1,a[tl]);
    }
    else
    {
      // Merge the two nodes in a sorted order
      int tm = (tl+tr)/2;
      build(a,2*v,tl,tm);
      build(a,2*v+1,tm+1,tr);
      merge(full(t[2*v]),full(t[2*v+1]),back_inserter(t[v]));
    }
  }

  // Find count of indices in the range [l,r] such that it is >= x.
  int query(int v, int tl, int tr, int l, int r, int x)
  {
    if (l > r)
    {
      return 0;
    }
    if (l==tl && r == tr)
    {
      auto it = lower_bound(full(t[v]),x);
      return t[v].end() - it;
    }

    int tm = (tl+tr)/2;
    return query(2*v,tl,tm,l,min(r,tm),x) + query(2*v+1,tm+1,tr,max(tm+1,l),r,x);
  }
};
endsnippet
