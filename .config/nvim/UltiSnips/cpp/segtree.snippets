snippet implicitsegtree
struct SegTreeNode {
  // Node values
  int sum = 0;

  int left, right; // Segment bounds
  SegTreeNode *left_child = nullptr, *right_child = nullptr; // Children

  // Segment for range [lb,rb)
  SegTreeNode(int lb, int rb)
  {
    left = lb;
    right = rb;
  }

  void extend()
  {
    // Split the range into two equal subranges, if possible
    if (!left_child && left+1 < right)
    {
      int t = (left+right)/2;
      left_child = new SegTreeNode(left,t);
      right_child = new SegTreeNode(t,right);
    }
  }

  void update(int pos, int val)
  {
    extend();
    sum += val;
    if (left_child)
    {
      if (pos < left_child->right)
        left_child->update(pos,val);
      else
        right_child->update(pos,val);
    }
  }

  int query(int lq, int rq)
  {
    if (lq <= left && right <= rq)
      return sum;
    if (max(left,lq) >= min(right,rq))
      return 0;
    extend();
    return left_child->query(lq,rq) + right_child->query(lq,rq);
  }
};
endsnippet

snippet itsegtree
// Remember to handle identity everywhere.
struct S {
  int x;

  // This should be the identity element
  S() {
    x = 0;
  }
  
  S(int _x):x(_x){}
};

struct segtree
{
  int _n;
  vector<S> t;
  int size;
  int log;

  S op(S& a, S& b) {
    return {max(a.x,b.x)};
  }

  segtree(int n = -1) {
    if (n >= 0)
      init(n);
  }

  segtree(vector<S>& v) {
    build(v);
  }

  void init(int n) {
    _n = n;
    log = 0;
    while ((1U<<log) < (unsigned int)(n)) log++;
    size = 1<<log;
    t.assign(2*size,S());
  }

  void build(vector<S>& v) {
    init((int)v.size());
    assert(_n != 0);

    for (int i = 0; i < _n; i++)
      t[size+i] = v[i];

    for (int i = size-1; i > 0; i--)
      t[i] = op(t[2*i],t[2*i+1]);
  }

  void update(int p, S x) {
    assert(0 <= p && p < _n);
    p += size;
    t[p] = x;
    for (int i = 1; i <= log; i++)
      t[p>>i] = op(t[2*(p>>i)],t[2*(p>>i)+1]);
  }

  S get(int p) {
    assert(0 <= p && p < _n);
    return t[p+size];
  }

  // Find result for range [l,r)
  S query(int l, int r) {
    assert(0 <= l && l <= r && r <= _n);
    S ansl, ansr;
    l += size;
    r += size;
    while (l < r)
    {
      if (l&1) ansl = op(ansl,t[l++]);
      if (r&1) ansr = op(t[--r],ansr);
      l >>= 1;
      r >>= 1;
    }
    return op(ansl,ansr);
  }
};
endsnippet

snippet itlazysegtree
// Remember to handle identity everywhere.
struct S {
  int x;
  int w;

  // This should be the identity element
  S() {
    x = 0;
    w = 1;
  }

  S(int _x, int _w):x(_x), w(_w){}
};

// Paremeters of the function we are applying on the range.
struct F{
  int d;
  // Must be identity
  F() {d=0;}
  F(int _d):d(_d){}
};

struct LazySegTree
{
  int _n;
  vector<S> t;
  vector<F> lz;
  S S_ID = S();
  F F_ID = F();
  int size;
  int log;

  // Returns the transform with parameters F and input S
  // Handle identity
  S mapping(F f, S x) {
    if (f.d==0)
      return x;
    return S();
  }

  // Returns f o g, which is the composition of them under the operation op
  // It is necessary that f(x) o f(y) = f(x o y). HANDLE IDENTITY
  F composition(F f, F g) {
    if (f.d==0) return g;
    return f;
  }

  S op(S a, S b) {
    return S(a.x*b.w+b.x,a.w*b.w);
  }

  LazySegTree(int n = -1) {
    if (n >= 0)
      init(n);
  }

  LazySegTree(vector<S>& v) {
    build(v);
  }

  void init(int n) {
    _n = n;
    log = 0;
    while ((1U<<log) < (unsigned int)(n)) log++;
    size = 1<<log;
    t.assign(2*size,S_ID);
    lz = vector<F>(size, F_ID);
  }

  void build(vector<S>& v) {
    init((int)v.size());
    assert(_n != 0);

    for (int i = 0; i < _n; i++)
      t[size+i] = v[i];

    for (int i = size-1; i > 0; i--)
      t[i] = op(t[2*i],t[2*i+1]);
  }

  void all_apply(int k, F f) {
    t[k] = mapping(f,t[k]);
    if (k < size) lz[k] = composition(f,lz[k]);
  }

  void push(int k) {
    all_apply(2*k,lz[k]);
    all_apply(2*k+1,lz[k]);
    lz[k] = F_ID;
  }

  void update(int p, S x) {
    assert(0 <= p && p < _n);
    p += size;
    for (int i = log; i >= 1; i--)
      push(p>>i);
    t[p] = x;
    for (int i = 1; i <= log; i++)
      t[p>>i] = op(t[2*(p>>i)],t[2*(p>>i)+1]);
  }

  S get(int p) {
    assert(0 <= p && p < _n);
    p += size;
    for (int i = log; i >= 1; i--)
      push(p>>i);
    return t[p];
  }

  // Find result for range [l,r)
  S query (int l, int r) {
    assert(0 <= l && l <= r && r <= _n);
    if (l==r) return S_ID;
    S ansl = S_ID, ansr = S_ID;
    l += size;
    r += size;

    for (int i = log; i >= 1; i--) {
      if (((l>>i)<<i) != l) push (l>>i);
      if (((r>>i)<<i) != r) push (r>>i);
    }

    while (l < r) {
      if (l&1) ansl = op(ansl,t[l++]);
      if (r&1) ansr = op(t[--r],ansr);
      l >>= 1;
      r >>= 1;
    }
    return op(ansl,ansr);
  }

  void apply(int p, F f) {
    assert(0 <= p && p < _n);
    p += size;
    for (int i = log; i >= 1; i--)
      push(p>>i);
    t[p] = mapping(f,t[p]);
    for (int i = 1; i <= log; i++)
      t[p>>i] = op(t[2*(p>>i)],t[2*(p>>i)+1]);
  }

  void apply(int l, int r, F f) {
    assert(0 <= l && l <= r && r <= _n);
    if (l==r) return;

    l += size;
    r += size;

    for (int i = log; i >= 1; i--) {
      if (((l >> i)<<i)!=l) push(l>>i);
      if (((r >> i)<<i)!=r) push((r-1)>>i);
    }

    {
      int l2 = l, r2 = r;
      while (l < r)
      {
        if (l&1) all_apply(l++,f);
        if (r&1) all_apply(--r,f);
        l >>= 1;
        r >>= 1;
      }
      l = l2, r = r2;
    }

    for (int i = 1; i <= log; i++) {
      if (((l >> i)<<i)!=l) t[l>>i] = op(t[2*(l>>i)],t[2*(l>>i)+1]);
      if (((r >> i)<<i)!=r) t[(r-1)>>i] = op(t[2*((r-1)>>i)],t[2*((r-1)>>i)+1]);
    }
  }
};
endsnippet

snippet persistentsegtree
struct PersistentSegTree {
  struct SegTreeNode {
    SegTreeNode *l, *r; // Children

    // Node values
    int mx;

    SegTreeNode(int val=0) : l(nullptr),r(nullptr),mx(val) {}
    SegTreeNode(SegTreeNode *l, SegTreeNode *r) : l(l),r(r),mx(0) {
      if (l) mx = max(mx,l->mx);
      if (r) mx = max(mx,r->mx);
    }
  };

  vector<SegTreeNode*> roots; // History
  int L, R; // Bounds

  PersistentSegTree(int tl, int tr) : L(tl), R(tr) {
    roots.push_back(build(tl,tr));
  }

  int size() { return (int)roots.size(); }

  SegTreeNode*& operator[](int idx) {
    assert(idx < roots.size());
    return roots[idx];
  }

  // Build segtree
  SegTreeNode* build(int tl, int tr) {
    if (tl==tr)
      return new SegTreeNode(0);
    int tm = (tl+tr)/2;
    return new SegTreeNode(build(tl,tm),build(tm+1,tr));
  }

  // Querying
  int query(int l, int r) {
    return query(roots.back(),l,r,L,R);
  }

  int query(int ind, int l, int r) {
    return query(roots[ind],l,r,L,R);
  }

  int query(SegTreeNode* v, int l, int r, int tl, int tr) {
    if (l > r) return 0;
    if (l == tl && r == tr) return v->mx;
    int tm = (tl+tr)/2;
    return max(query(v->l,l,min(r,tm),tl,tm),query(v->r,max(l,tm+1),r,tm+1,tr));
  }

  // Point updates
  void update(int pos, int val) {
    roots.push_back(update(roots.back(),pos,val,L,R));
  }

  SegTreeNode* update(SegTreeNode* v, int pos, int val, int tl, int tr) {
    if (tl==tr)
      return new SegTreeNode(val);
    int tm = (tl+tr)/2;
    if (pos <= tm)
      return new SegTreeNode(update(v->l,pos,val,tl,tm),v->r);
    else
      return new SegTreeNode(v->l,update(v->r,pos,val,tm+1,tr));
  }
};
endsnippet

snippet segtree
template<class T>
struct SegTree {
  int n;
  vector<T> t;
  T E = 0;

  T comb(T a, T b) { // Segtree function
    return a+b;
  }
  SegTree() {}
  SegTree(int _n) : n(_n), t(4*n+5) {}
  SegTree(vector<T>& bld) : n(bld.size()), t(4*n+5) {
    build(bld,1,0,n-1);
  }
  void build(vector<T>& bld, int node, int tl, int tr) {
    if (tl == tr) {
      t[node] = bld[tl];
    }
    else {
      int tm = (tl+tr)/2;
      build(bld,2*node,tl,tm);
      build(bld,2*node+1,tm+1,tr);
      pull(node);
    }
  }
  void pull(int node) { t[node] = comb(t[2*node], t[2*node+1]); }
  T query(int l, int r) {return query(l, r,1,0,n-1);}
  T query(int l, int r, int node, int tl, int tr) {
    if (r < tl || tr < l) return E;
    if (l <= tl && tr <= r) return t[node];
    int tm = (tl+tr)/2;
    return comb(query(l,r,2*node,tl,tm), query(l,r,2*node+1,tm+1,tr));
  }
  void update(int p, T val) { return update(p,val,1,0,n-1); }
  void update(int p, T val, int node, int tl, int tr) {
    if (tl == tr) {
      t[node] += val;
      return;
    }
    int tm = (tl+tr)/2;
    if (p <= tm) update(p,val,2*node,tl,tm);
    else update(p,val,2*node+1,tm+1,tr);
    pull(node);
  }
};
endsnippet

snippet lazysegtree
// My simple use lazy segtree
template<class T>
struct LazySegTree {
  int n;
  vector<T> t, lz;
  T E = 0;
  T ID = 0;

  T comb(T a, T b) { // Segtree function
    return a+b;
  }
  void push(int node, int l, int r) { // Propagation
    t[node] += (r-l+1)*lz[node];
    if (l != r) { // Propagate
      for (int it = 0; it < 2; it++){
        lz[2*node+it] += lz[node];
      }
    }
    lz[node] = ID;
  }
  LazySegTree() {}
  LazySegTree(int _n) : n(_n), t(4*n+5), lz(4*n+5) {
  }
  LazySegTree(vector<T>& bld) : n(bld.size()), t(4*n+5), lz(4*n+5) {
    build(bld,1,0,n-1);
  }
  void build(vector<T>& bld, int node, int tl, int tr) {
    if (tl == tr) {
      t[node] = bld[tl];
    }
    else {
      int tm = (tl+tr)/2;
      build(bld,2*node,tl,tm);
      build(bld,2*node+1,tm+1,tr);
      pull(node);
    }
  }
  void pull(int node) { t[node] = comb(t[2*node], t[2*node+1]); }
  void apply(int l, int r, T val) { apply(l,r,val,1,0,n-1); }
  void apply(int l, int r, T val, int node, int tl, int tr) {
    push(node,tl,tr);
    if (r < tl || tr < l) return;
    if (l <= tl && tr <= r) {
      lz[node] = val;
      push(node,tl,tr);
      return;
    }
    int tm = (tl+tr)/2;
    apply(l,r,val,2*node,tl,tm);
    apply(l,r,val,2*node+1,tm+1,tr);
    pull(node);
  }
  T query(int l, int r) {return query(l, r,1,0,n-1);}
  T query(int l, int r, int node, int tl, int tr) {
    push(node,tl,tr);
    if (r < tl || tr < l) return E;
    if (l <= tl && tr <= r) return t[node];
    int tm = (tl+tr)/2;
    return comb(query(l,r,2*node,tl,tm), query(l,r,2*node+1,tm+1,tr));
  }
};
endsnippet

snippet lazysegtree_alt
// More general lazy segtree
struct LazySegTree {
  struct F { // Lazy update
    ll inc = 0;
    F() {} // identity
    F(int x) : inc(x) {}
    F& operator *= (const F& a) { // Compose a onto this (a is new)
      inc += a.inc;
      return *this;
    }
  };
  struct T { // Segtree data
    ll sz = 1, sum = 0;
    T() {} // identity
    T(int x) : sum(x) {}
    friend T operator+(const T& a, const T& b) { // Combine two data
      T res;
      res.sz = a.sz + b.sz;
      res.sum = a.sum + b.sum;
      return res;
    }
    T& operator*=(const F& a) { // Apply lazy onto data
      sum += sz*a.inc;
      return *this;
    }
  };
  int n;
  vector<T> t;
  vector<F> lz;

  LazySegTree() {}
  LazySegTree(vector<T>& v) {
    n = 1;
    while(n < v.size()) n *= 2;
    t.resize(2*n);
    lz.resize(2*n);
    for (int i = 0; i < v.size(); i++) t[n+i] = v[i];
    for (int i = n-1; i >= 1; i--) pull(i);
  }
  
  void push(int node) {
    t[node] *= lz[node];
    if (node < n) {
      lz[2*node] *= lz[node];
      lz[2*node+1] *= lz[node];
    }
    lz[node] = F();
  }
  void pull(int node) {
    t[node] = t[2*node] + t[2*node+1];
  }
  T query(int l, int r) {
    return query(l,r,1,0,n-1);
  }
  T query(int l, int r, int node, int tl, int tr) {
    push(node);
    if (tr < l || tl > r) return T();
    if (l <= tl && tr <= r) return t[node];
    int tm = (tl+tr)/2;
    return query(l,r,2*node,tl,tm) + query(l,r,2*node+1,tm+1,tr);
  }
  void apply(int l, int r, F val) {
    apply(l,r,val,1,0,n-1);
  }
  void apply(int l, int r, F val, int node, int tl, int tr) {
    push(node);
    if (tr < l || tl > r) return;
    if (l <= tl && tr <= r) {
      lz[node] = val;
      push(node);
      return;
    }
    int tm = (tl+tr)/2;
    apply(l,r,val,2*node,tl,tm);
    apply(l,r,val,2*node+1,tm+1,tr);
    pull(node);
  }
};
endsnippet

snippet segtree_alt
// More general segtree
struct SegTree {
  struct T { // Segtree data
    ll sz = 0, sum = 0;
    T() {} // identity
    T(int x) : sum(x) {}
    friend T operator+(const T& a, const T& b) { // Combine two data
      T res;
      res.sz = a.sz + b.sz;
      res.sum = a.sum + b.sum;
      return res;
    }
  };
  int n;
  vector<T> t;
  SegTree() {}
  SegTree(vector<T>& v) {
    n = 1;
    while(n < v.size()) n *= 2;
    t.resize(2*n);
    for (int i = 0; i < v.size(); i++) t[n+i] = v[i];
    for (int i = n-1; i >= 1; i--) pull(i);
  }
  void pull(int node) {
    t[node] = t[2*node] + t[2*node+1];
  }
  T query(int l, int r) { return query(l,r,1,0,n-1); }
  T query(int l, int r, int node, int tl, int tr) {
    if (tr < l || tl > r) return T();
    if (l <= tl && tr <= r) return t[node];
    int tm = (tl+tr)/2;
    return query(l,r,2*node,tl,tm) + query(l,r,2*node+1,tm+1,tr);
  }
  void update(int p, T x) { return update(p,x,1,0,n-1); }
  void update(int p, T x, int node, int tl, int tr) {
    if (tl == tr) {
      t[node] = t[node] + x;
      return;
    }
    int tm = (tl+tr)/2;
    if (p <= tm) update(p,x,2*node,tl,tm);
    else update(p,x,2*node+1,tm+1,tr);
    pull(node);
  }
};
endsnippet
