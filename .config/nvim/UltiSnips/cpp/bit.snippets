snippet fenwick
// Source: Me
// Tested On: Yosupo Point Add Range Sum
template <class T = int>
struct Fenwick {
  vector<T> t;
  int tn;

  Fenwick(int _n) {
    assert(_n > 0);
    tn = _n;
    t = vector<T>(tn+1);
  }

  // Update a[x] by val
  void update(int x, T val) {
    x++;
    while (x <= tn) {
      t[x] += val;
      x += (x&-x);
    }
  }

  // Find sum in [0..x]
  T query(int x) {
    assert(x < tn);
    x++;
    T res = 0;
    while (x > 0) {
      res += t[x];
      x -= (x&-x);
    }
    return res;
  }

  // Find sum in [l..r]
  T query(int l, int r) {
    assert(l <= r);
    if (l==0)
      return query(r);
    return query(r)-query(l-1);
  }

  // Returns the smallest p in [0,tn] such that query(p) > sum
  int find_last_prefix(T sum){
    if (sum < 0)
      return -1;
    int pref = 0;
    for (int k = 31 - __builtin_clz(tn); k >= 0; k--) {
      if (pref + (1<<k) <= tn && t[pref+(1<<k)] <= sum){
        pref += 1<<k;
        sum -= t[pref];
      }
    }
    return pref;
  }
};
endsnippet

snippet rectcount
// Source: Me
// Tested on: CF 1093 E
// Count number of points in a rectangle with add/remove
// point queries online in O(log2n) with O(nlogn) memory
// Ordered set can be swapped out with treap
// x can range from [1,n] 
struct RectangleCount {
  int n;
  vector<ordered_set<pair<int,int>>> points;

  RectangleCount(int _n):n(_n), points(_n+1) {}

  void insert(int x, int y) {
    for (int i = x; i <= n; i += i&-i)
      points[i].insert({y,x});
  }

  void erase(int x, int y) {
    for (int i = x; i <= n; i += i&-i)
      points[i].erase({y,x});
  }

  int query(int x, int y) {
    int res = 0;
    for (; x > 0; x -= x&-x) res += points[x].order_of_key({y,1e9+7});
    return res;
  }

  // Find number of points in the rectangle [lx,rx] x [ly,ry]
  int query(int lx,int rx, int ly, int ry) {
    return query(rx,ry) - query(lx-1,ry) - query(rx,ly-1) + query(lx-1,ly-1);
  }
};
endsnippet
