snippet nck
vector<mod_int> fact, invfact, inv;

void prepare_factorials(int N) {
  assert(N >= 2);
  fact.resize(N+1);
  invfact.resize(N+1);
  inv.resize(N+1);
  inv[1] = invfact[1] = invfact[0] = fact[0] = fact[1] = 1;
  for (int i = 2; i <= N; i++) {
    fact[i] = fact[i-1]*i;
    inv[i] = inv[MOD%i]*(MOD-MOD/i);
    invfact[i] = invfact[i-1]*inv[i];
  }
}

mod_int choose(int n, int k) {
  if (n < k) return 0;
  if (n < 0 || k < 0) return 0;
  return fact[n]*(invfact[k]*invfact[n-k]);
}
endsnippet

snippet sieve
const int N = 1e5+7;
bool prime[N];

void sieve()
{
    memset(prime,true,sizeof(prime));

    for (int p = 2; p*p <= N; p++)
    {
        if (prime[p])
        {
	        for (int i = p*p; i <= N-1; i += p)
	          prime[i] = false;
        }
    }
}
endsnippet

snippet floorsum
// AtCoder Library implementation
// Find sum of floor((ai+b)/m), 0 <= i <= n-1
// O(log(n+m+a+b))
// Tested on ARC111 E
ll floor_sum(ll n, ll m, ll a, ll b) {
    ll ans = 0;
    if (a >= m) {
        ans += (n - 1) * n * (a / m) / 2;
        a %= m;
    }
    if (b >= m) {
        ans += n * (b / m);
        b %= m;
    }
 
    ll y_max = (a * n + b) / m, x_max = (y_max * m - b);
    if (y_max == 0) return ans;
    ans += (n - (x_max + a - 1) / a) * y_max;
    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);
    return ans;
}
endsnippet

snippet invgcd
// returns a pair (g,x) such that:
// g = gcd(a,b)
// xa = g mod b
// 0 <= x < b/g;
pair<ll,ll> inv_gcd(ll a, ll b) {
  a = a%b;
  if (a < 0) a += b;
  if (a==0) return {b,0};
  ll s = b, t = a;
  ll m0 = 0, m1 = 1;
  while(t) {
    ll u = s/t;
    s -= t*u;
    m0 -= m1*u;
    auto tmp = s;
    s = t;
    t = tmp;
    tmp = m0;
    m0 = m1;
    m1 = tmp;
  }
  if (m0 < 0) m0 += b/s;
  return {s,m0};
}
endsnippet

snippet crt
// Takes as input list of residues and mods
// If there is no solution, returns {0,0}
// Otherwise, returns (y,z) such that all solutions are x = y mod z
// Complexity : O(n log(lcm))
pair<ll,ll> crt(const vector<ll>& r, vector<ll>& m) {
  assert(r.size() == m.size());
  int n = (int)r.size();
  ll r0 = 0, m0 = 1;
  for (int i = 0; i < n; i++) {
    assert(1 <= m[i]);
    ll r1 = r[i]%m[i], m1 = m[i];
    if (r1 < 0) r1 += m[i];
    if (m0 < m1) {
      swap(r0,r1);
      swap(m0,m1);
    }
    if (m0 % m1 == 0) {
      if (r0 %m1 != r1) return {0,0};
      continue;
    }
    ll g, im;
    tie(g,im) = inv_gcd(m0,m1);
    ll u1 = m1/g;
    if ((r1-r0)%g) return {0,0};
    ll x = (r1-r0)/g%u1 * im%u1;
    r0 += x*m0;
    m0 *= u1;
    if (r0 < 0) r0 += m0;
  }
  return {r0,m0};
}
endsnippet
