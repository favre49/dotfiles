snippet matrix
// Source: Nyaan
// Tested On:
// Matrix library
// Use M^k to raise to a power
template<class T>
struct Matrix{
  vector<vector<T>> A;

  Matrix() = default;
  Matrix(int n):A(n,vector<T>(n,T())) {}
  Matrix(int n, int m):A(n,vector<T>(m,T())) {}

  int H() const { return A.size(); }
  int W() const { return A[0].size(); }

  vector<T>& operator[] (int index) { return A[index]; }
  const vector<T>& operator[] (int index) const { return A[index]; }

  static Matrix I(int n) {
    Matrix id(n);
    for (int i =0; i < n; i++) id[i][i] = 1;
    return id;
  }

  Matrix& operator+=(const Matrix& B) {
    int n = H(), m = W();
    assert(n == B.H() && m == B.W());
    for (int i = 0; i < n; i++)
      for (int j = 0; j < m; j++)
        (*this)[i][j] += B[i][j];
    return *this;
  }

  Matrix& operator-=(const Matrix& B) {
    int n = H(), m = W();
    assert(n == B.H() && m == B.W());
    for (int i = 0; i < n; i++)
      for (int j = 0; j < m; j++)
        (*this)[i][j] -= B[i][j];
    return *this;
  }
  
  Matrix& operator*=(const Matrix& B) {
    int n = H(), m = W();
    int bn = B.H(), bm = B.W();
    assert(m == bn);
    vector<vector<T>> C(n,vector<T>(bm,T()));
    for (int i = 0; i < n; i++)
      for (int k = 0; k < m; k++)
        for (int j = 0; j < bm; j++)
          C[i][j] += (*this)[i][k]*B[k][j];
    A.swap(C);
    return *this;
  }

  Matrix& operator^=(int64_t k) {
    Matrix B = Matrix::I((*this).H());
    while(k > 0) {
      if (k&1) B *= *this;
      *this *= *this;
      k >>= 1;
    }
    A.swap(B.A);
    return *this;
  }

  Matrix operator+(const Matrix& B) const { return (Matrix(*this) += B); }
  Matrix operator-(const Matrix& B) const { return (Matrix(*this) -= B); }
  Matrix operator*(const Matrix& B) const { return (Matrix(*this) *= B); }
  Matrix operator^(const int64_t k) const { return (Matrix(*this) ^= k); }

  bool operator==(const Matrix& B) const {
    assert(H() == B.H() && W() == B.W());
    for (int i =0 ; i < H(); i++)
      for (int j = 0; j < W(); j++)
        if (A[i][j] != B[i][j]) return false;
    return true;
  }

  bool operator!=(const Matrix& B) const {
    assert(H() == B.H() && W() == B.W());
    for (int i =0 ; i < H(); i++)
      for (int j = 0; j < W(); j++)
        if (A[i][j] != B[i][j]) return true;
    return false;
  }

  // Get the determinant of the matrix in O(N^3)
  // Remember to make all n into n-1 when using with Kirchhoff's theorem
  T det() {
    int n = H(), m = W();
    assert(n == m);
    Matrix B(*this);
    T prod = 1;
    for (int i =0 ; i < n; i++) {
      int idx = -1;
      for (int j = i; j < n; j++) {
        if (B[j][i] != 0) {
          idx = j;
          break;
        }
      }
      if (idx == -1) return 0;
      if (i != idx) {
        prod *= T(-1);
        swap(B[i],B[idx]);
      }
      prod *= B[i][i];
      T inv = T(1)/B[i][i];
      for (int j =0 ; j < n; j++)
        B[i][j] *= inv;
      for (int j = i+1; j < n; j++) {
        T a = B[j][i];
        if (a==0) continue;
        for (int k = i; k < m; k++)
          B[j][k] -= B[i][k]*a;
      }
    }
    return prod;
  }
};
endsnippet

snippet submat
// Source: KACTL
// Tested On: Nothing yet
template<typename T>
struct SubMatrix {
  vector<vector<T>> p;
  SubMatrix(vector<vector<T>>& v) {
    int r = v.size(), c = v[0].size();
    p.assign(r+1,vector<T>(c+1));
    for (int i =0;i < r; i++)
      for (int j = 0; j < c; j++)
        p[i+1][j+1] = v[i][j]+p[i][j+1]+p[i+1][j]-p[i][j];
  }
  // find sum with top left (x1,y1) and bot right (x2,y2)
  T sum(int x1, int y1, int x2, int y2) {
    x2++,y2++;
    return p[x2][y2]-p[x1][y2]-p[x2][y1]+p[x1][y1];
  }
};
endsnippet

snippet matinv
// Source: KACTL
// Tested on: Yosupo Matrix Inverse
// Finds inverse of a matrix
// Returns the rank of a matrix, i.e. only inverted if
// rank == n
int inverse(vector<vector<mod_int>>& A) {
  int n = A.size();
  vector<int> col(n);
  vector<vector<mod_int>> tmp(n,vector<mod_int>(n));
  for (int i =0; i < n; i++) {
    tmp[i][i] = 1;
    col[i] = i;
  }
  for (int i = 0; i < n; i++) {
    int r = i, c =i;
    for (int j = i; j < n; j++) {
      for (int k = i; k < n; k++) {
        if (A[j][k] != 0) {
          r = j;
          c = k;
          goto found;
        }
      }
    }
    return i;
found:;
    A[i].swap(A[r]);
    tmp[i].swap(tmp[r]);
    for (int j =0; j < n; j++) {
      swap(A[j][i], A[j][c]);
      swap(tmp[j][i],tmp[j][c]);
    }
    swap(col[i],col[c]);
    mod_int v = A[i][i].inv();
    for (int j = i+1; j < n; j++) {
      mod_int f = A[j][i]*v;
      A[j][i] = 0;
      for (int k = i+1; k < n; k++)
        A[j][k] -= f*A[i][k];
      for (int k = 0; k < n; k++)
        tmp[j][k] -= f*tmp[i][k];
    }
    for (int j = i+1; j < n; j++)
      A[i][j] *= v;
    for (int j =0; j < n; j++)
      tmp[i][j] *= v;
    A[i][i] = 1;
  }
  for (int i = n-1; i >= 0; i--) {
    for (int j = 0; j < i; j++) {
      mod_int v = A[j][i];
      for (int k = 0; k < n; k++)
        tmp[j][k] -= v*tmp[i][k];
    }
  }
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
      A[col[i]][col[j]] = tmp[i][j];
  return n;
}
endsnippet
