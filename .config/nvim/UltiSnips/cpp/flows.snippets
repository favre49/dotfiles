snippet dinic
// Find the max flow through a directed graph
// works in O(V^2E)
#include "bits/stdc++.h"

using namespace std;
using ll = long long;
using pii = pair<int,int>;

template<typename T = int>
struct Dinic {
  // Edge u->v with capacity cap
  struct FlowEdge {
    int u,v;
    T cap, flow = 0;
    FlowEdge(int u, int v, ll cap) : u(u),v(v),cap(cap) {}
  };

  const T INF = numeric_limits<T>::max();
  vector<FlowEdge> edges;
  vector<vector<int>> adj;
  int n,m = 0;
  int s,t;
  vector<int> level, ptr;
  queue<int> q;

  Dinic(int n, int s, int t) : n(n), s(s), t(t) {
    adj.resize(n); level.resize(n); ptr.resize(n);
  }
  void add_edge(int u,int v, T cap) {
    edges.push_back({u,v,cap});
    edges.push_back({v,u,0});
    adj[u].push_back(m);
    adj[v].push_back(m+1);
    m += 2;
  }
  bool bfs() {
    while(!q.empty()) {
      int u = q.front();
      q.pop();
      for (int e : adj[u]) {
        if (edges[e].cap - edges[e].flow < 1) continue;
        if (level[edges[e].v] != -1) continue;
        level[edges[e].v] = level[u]+1;
        q.push(edges[e].v);
      }
    }
    return level[t] != -1;
  }
  T dfs(int u, T pushed) {
    if (pushed == 0) return 0;
    if (u==t) return pushed;
    for (int& cid = ptr[u]; cid < (int) adj[u].size(); cid++) {
      int id = adj[u][cid];
      int v = edges[id].v;
      if (level[u]+1!=level[v]||edges[id].cap -edges[id].flow<1) continue;
      T tr = dfs(v,min(pushed,edges[id].cap-edges[id].flow));
      if (tr==0) continue;
      edges[id].flow += tr;
      edges[id^1].flow -= tr;
      return tr;
    }
    return 0;
  }
  T flow() {
    T f = 0;
    while(1) {
      fill(level.begin(),level.end(),-1);
      level[s] = 0;
      q.push(s);
      if (!bfs()) break;
      fill(ptr.begin(),ptr.end(),0);
      while(T pushed = dfs(s,INF))
        f += pushed;
    }
    return f;
  }
  vector<bool> min_cut() {
    vector<bool> res(n);
    for (int i = 0; i < n; i++)
      res[i] = (level[i] != -1);
    return res;
  }
};
endsnippet

snippet pushrelabel
template <class F> struct PushRelabel {
  struct Edge { int to, rev; F flow; };
  const F INF = numeric_limits<F>::max();  
  int n, s, t, highest, work;
  vector<vector<Edge>> adj;
  vector<vector<int>> lst, gap;
  vector<int> height, cnt;
  vector<F> excess;

  PushRelabel(int n_) {
    n = n_;
    adj.clear(); adj.resize(2 * n);
    lst.clear(); lst.resize(2 * n);
    gap.clear(); gap.resize(2 * n);
    height.assign(2 * n, 0);
    cnt.assign(2 * n, 0);
    excess.assign(2 * n, 0);
    work = highest = 0;
  }
  void add_edge(int u, int v, F cap) {
    assert(cap >= 0);
    Edge a{v,(int)adj[v].size(),cap};
    Edge b{u,(int)adj[u].size(),0};
    adj[u].push_back(a);
    adj[v].push_back(b);
  }
  void update_height(int v, int nh) {
    work++;
    if (height[v] != n) cnt[height[v]]--;
    height[v] = nh;
    if (nh == n) return;
    cnt[nh]++;
    highest = nh;
    gap[nh].push_back(v);
    if (excess[v] > 0) lst[nh].push_back(v);
  }
  void global_relabel() {
    work = 0;
    for (int i = 0; i < n; i++)
      height[i] = n, cnt[i] = 0;
    for (int i = 0; i < highest; i++) 
      lst[i].clear(), gap[i].clear();
    height[t] = 0;
    queue<int> q({t});
    while (!q.empty()) {
      int v = q.front();
      q.pop();
      for (auto& e : adj[v]) 
        if (height[e.to] == n && adj[e.to][e.rev].flow > 0)
          q.push(e.to), update_height(e.to, height[v] + 1);
      highest = height[v];
    }
  }
  void push(int v, Edge& e) {
    if (excess[e.to] == 0)
      lst[height[e.to]].push_back(e.to);
    F df = std::min(excess[v], e.flow);
    e.flow -= df, adj[e.to][e.rev].flow += df;
    excess[v] -= df, excess[e.to] += df;
  }
  void discharge(int v) {
    int nh = n;
    for (auto& e : adj[v]) 
      if (e.flow > 0)
        if (height[v] == height[e.to] + 1) {
          push(v, e);
          if (excess[v] <= 0) return;
        } else {
          nh = std::min(nh, height[e.to] + 1);
        }
    if (cnt[height[v]] > 1) 
      update_height(v, nh);
    else {
      for (int i = height[v]; i <= highest; i++) {
        for (auto& j : gap[i])
          update_height(j, n);
        gap[i].clear();
      }
    }
  }
  F max_flow(int s_, int t_) {
    s = s_, t = t_;
    if (s == t)
      return -1;
    for (int i = 0; i < n; i++)
      excess[i] = 0;
    excess[s] = INF, excess[t] = -INF;
    global_relabel();
    for (auto& e : adj[s]) 
      push(s, e);
    for (; highest >= 0; highest--)
      while (!lst[highest].empty()) {
        int v = lst[highest].back();
        lst[highest].pop_back();
        discharge(v);
        if (work > 4 * n)
          global_relabel();
      }
    return excess[t] + INF; //???
  }
};
endsnippet
