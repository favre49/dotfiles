snippet polynomial
template <typename T>
struct poly {
  // The coefficients of the polynomial in increasing order of degree
  vector<T> a;

  // Constructors
  poly(){}
  poly(T _a):a{_a} {}
  poly(vector<T> t):a(t) {}

  // Operations
  poly operator += (const poly& t)
  {
    a.resize(max(a.size(),t.a.size()));
    for (int i = 0; i< t.a.size(); i++)
      a[i] += t.a[i];
    return *this;
  }

  poly operator -= (const poly& t)
  {
    a.resize(max(a.size(),t.a.size()));
    for (int i = 0; i< t.a.size(); i++)
      a[i] -= t.a[i];
    return *this;
  }

  // Note: Should I make this FFT? Probably not yet
  poly operator *= (const poly& t)
  {
    vector<T> ans(a.size()+t.a.size()-1);
    for (int i = 0; i < (int)a.size(); i++)
      for (int j = 0; j < (int)t.a.size(); j++)
        ans[i+j] += a[i]*t.a[j];
    a = ans;
    return *this;
  }

  poly operator /= (T d)
  {
    for (int i = 0; i < a.size(); i++)
      a[i] /= d;
    return *this;
  }

  T operator () (T x)
  {
    T res = 0;
    T cum = 1;
    for (int i = 0; i < a.size(); i++)
    {
      res += a[i]*cum;
      cum *= x;
    }
    return res;
  }

  poly operator + (const poly& t) const {return poly(*this) += t;}
  poly operator - (const poly& t) const {return poly(*this) -= t;}
  poly operator * (const poly& t) const {return poly(*this) *= t;}
  poly operator / (T t) const {return poly(*this) /= t;}

  // More operations
  poly integrate()
  {
    vector<T> res = {0};
    for (int i = 0; i < a.size(); i++)
    {
      res.push_back(a[i]/T(i+1));
    }
    return res;
  }

  poly deriv()
  {
    vector<T> res;
    for (int i = 1; i < a.size(); i++)
      res.push_back(a[i]*T(i));
    return res;
  }
  
  T integrate_val(int l, int r)
  {
    poly ans = integrate();
    return ans(r)-ans(l);
  }
};
endsnippet
