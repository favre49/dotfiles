snippet rmq
template<typename T, bool maximum_mode = false>
struct RMQ {
    int n = 0;
    vector<T> values;
    vector<vector<int>> range_low;
 
    RMQ(const vector<T> &_values = {}) {
        if (!_values.empty())
            build(_values);
    }
 
    static int largest_bit(int x) {
        return x == 0 ? -1 : 31 - __builtin_clz(x);
    }
 
    // Note: when `values[a] == values[b]`, returns b.
    int better_index(int a, int b) const {
        return (maximum_mode ? values[b] < values[a] : values[a] < values[b]) ? a : b;
    }
 
    void build(const vector<T> &_values) {
        values = _values;
        n = int(values.size());
        int levels = largest_bit(n) + 1;
        range_low.resize(levels);
 
        for (int k = 0; k < levels; k++)
            range_low[k].resize(n - (1 << k) + 1);
 
        for (int i = 0; i < n; i++)
            range_low[0][i] = i;
 
        for (int k = 1; k < levels; k++)
            for (int i = 0; i <= n - (1 << k); i++)
                range_low[k][i] = better_index(range_low[k - 1][i], range_low[k - 1][i + (1 << (k - 1))]);
    }
 
    // Note: breaks ties by choosing the largest index.
    int query_index(int a, int b) const {
        assert(0 <= a && a < b && b <= n);
        int level = largest_bit(b - a);
        return better_index(range_low[level][a], range_low[level][b - (1 << level)]);
    }
 
    T query_value(int a, int b) const {
        return values[query_index(a, b)];
    }
};
endsnippet

snippet monoq
template<typename T>
struct MonoQueue {
    deque<pair<T, int>> values;
    int current_index = 0;
 
    bool better(const T &a, const T &b) const {
        return a > b;
    }
 
    // Adds a value and returns its index.
    int add(const T &x) {
        while (!values.empty() && !better(values.back().first, x))
            values.pop_back();
 
        values.emplace_back(x, current_index);
        return current_index++;
    }
 
    // Queries for the maximum (minimum) with index at least the given `index`.
    T query(int index) {
        while (!values.empty() && values.front().second < index)
            values.pop_front();
 
        assert(!values.empty());
        return values.front().first;
    }
};
endsnippet

snippet rmq2d
// Source: Me
// Tested on: CF 1301 E
// 2D Sparse Table, finds MAXIMUM. Just change all max to min for MIN
template<typename T>
struct RMQ2D {
  int n,m;
  tensor<T,4> table;
  vector<int> logs;

  RMQ2D(vector<vector<T>>& matrix) {
    n = matrix.size();
    m = matrix[0].size();
    logs.resize(max(n,m)+1);
    int lgn = __lg(n)+1;
    int lgm = __lg(m)+1;
    table = tensor<T,4>({lgn,lgm,n,m});
    for (int i = 2; i <= max(n,m); i++) {
      logs[i] = logs[i-1];
      if ((1<<(logs[i]+1)) == i)
        logs[i]++;
    }
    for (int i =0; i < n; i++)
      for (int j = 0; j < m; j++)
        table[{0,0,i,j}] = matrix[i][j];
    for (int k = 1; k < lgn; k++)
      for (int i = 0; i +(1<<k) <= n; i++)
        for (int j = 0; j < m; j++)
          table[{k,0,i,j}] = max(table[{k-1,0,i,j}],table[{k-1,0,i+(1<<(k-1)),j}]);
    for (int l = 1; l < lgm; l++)
      for (int k = 0; k < lgn; k++)
        for (int i = 0; i+(1<<k) <= n; i++)
          for (int j = 0; j + (1<<l) <= m; j++)
            table[{k,l,i,j}] = max(table[{k,l-1,i,j}],table[{k,l-1,i,j+(1<<(l-1))}]);
  };

  // Query for maximum in the submatrix with top left (r1,c1) and bottom right
  // (r2,c2)
  T query(int r1, int c1, int r2, int c2) {
    if (r2 < r1 || c2 < c1 || r1 < 0 || r2 >= n || c1 < 0 || c2 >= m) return -1e8;
    int a = logs[(r2-r1)+1];
    int b = logs[(c2-c1)+1];
    return max({table[{a,b,r1,c1}],table[{a,b,r2-(1<<a)+1,c1}],table[{a,b,r1,c2-(1<<b)+1}], table[{a,b,r2-(1<<a)+1,c2-(1<<b)+1}]});
  }
};
endsnippet
